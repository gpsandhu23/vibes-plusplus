[
    {
      "input": "Create a Pydantic model for a User with fields: id (integer), username (string), email (string), and is_active (boolean). Include appropriate type hints and field constraints.",
      "ideal": "from pydantic import BaseModel, EmailStr, Field\n\nclass User(BaseModel):\n    \"\"\"Pydantic model representing a user.\"\"\"\n    id: int = Field(..., gt=0, description=\"Unique identifier for the user\")\n    username: str = Field(..., min_length=3, max_length=50, description=\"User's username\")\n    email: EmailStr = Field(..., description=\"User's email address\")\n    is_active: bool = Field(default=True, description=\"Flag indicating if the user account is active\")\n\n    class Config:\n        \"\"\"Pydantic model configuration.\"\"\"\n        schema_extra = {\n            \"example\": {\n                \"id\": 1,\n                \"username\": \"john_doe\",\n                \"email\": \"john.doe@example.com\",\n                \"is_active\": True\n            }\n        }"
    },
    {
      "input": "Write a function that takes a list of integers and returns the sum of all even numbers in the list. Use type hinting and include a docstring.",
      "ideal": "from typing import List\n\ndef sum_even_numbers(numbers: List[int]) -> int:\n    \"\"\"Calculate the sum of all even numbers in the given list.\n\n    Args:\n        numbers (List[int]): A list of integers.\n\n    Returns:\n        int: The sum of all even numbers in the list.\n\n    Example:\n        >>> sum_even_numbers([1, 2, 3, 4, 5, 6])\n        12\n    \"\"\"\n    return sum(num for num in numbers if num % 2 == 0)"
    },
    {
      "input": "Create an asynchronous function that fetches data from a URL using aiohttp and returns the JSON response. Handle potential errors and include type hinting.",
      "ideal": "import aiohttp\nfrom typing import Dict, Any\nfrom aiohttp import ClientSession\n\nasync def fetch_json_data(url: str) -> Dict[str, Any]:\n    \"\"\"Asynchronously fetch JSON data from the given URL.\n\n    Args:\n        url (str): The URL to fetch data from.\n\n    Returns:\n        Dict[str, Any]: The JSON response as a dictionary.\n\n    Raises:\n        aiohttp.ClientError: If there's an error during the HTTP request.\n        ValueError: If the response is not valid JSON.\n    \"\"\"\n    async with ClientSession() as session:\n        try:\n            async with session.get(url) as response:\n                response.raise_for_status()\n                return await response.json()\n        except aiohttp.ClientError as e:\n            raise aiohttp.ClientError(f\"Error fetching data from {url}: {str(e)}\")\n        except ValueError as e:\n            raise ValueError(f\"Error parsing JSON response from {url}: {str(e)}\")"
    },
    {
      "input": "Implement a decorator that measures the execution time of a function and logs it. Use type hinting and include a docstring.",
      "ideal": "import time\nfrom functools import wraps\nfrom typing import Callable, Any\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\ndef measure_time(func: Callable[..., Any]) -> Callable[..., Any]:\n    \"\"\"Decorator to measure the execution time of a function and log it.\n\n    Args:\n        func (Callable[..., Any]): The function to be measured.\n\n    Returns:\n        Callable[..., Any]: The wrapped function.\n\n    Example:\n        @measure_time\n        def slow_function():\n            time.sleep(2)\n    \"\"\"\n    @wraps(func)\n    def wrapper(*args: Any, **kwargs: Any) -> Any:\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        execution_time = end_time - start_time\n        logging.info(f\"{func.__name__} took {execution_time:.4f} seconds to execute.\")\n        return result\n    return wrapper"
    },
    {
      "input": "Create a context manager for handling file operations that automatically closes the file and handles exceptions. Use type hinting and include a docstring.",
      "ideal": "from typing import TextIO\nfrom types import TracebackType\nfrom typing import Optional, Type\n\nclass FileHandler:\n    \"\"\"A context manager for handling file operations.\n\n    This class provides a safe way to open and close files, automatically\n    handling file closure and exception management.\n\n    Args:\n        filename (str): The name of the file to open.\n        mode (str): The mode in which to open the file (e.g., 'r', 'w', 'a').\n\n    Example:\n        with FileHandler('example.txt', 'w') as f:\n            f.write('Hello, World!')\n    \"\"\"\n\n    def __init__(self, filename: str, mode: str) -> None:\n        self.filename = filename\n        self.mode = mode\n        self.file: Optional[TextIO] = None\n\n    def __enter__(self) -> TextIO:\n        self.file = open(self.filename, self.mode)\n        return self.file\n\n    def __exit__(self, exc_type: Optional[Type[BaseException]],\n                 exc_val: Optional[BaseException],\n                 exc_tb: Optional[TracebackType]) -> bool:\n        if self.file:\n            self.file.close()\n        if exc_type is not None:\n            print(f\"An error occurred: {exc_val}\")\n        return False  # Propagate the exception"
    },
    {
      "input": "Implement a custom iterator class that generates Fibonacci numbers up to a specified limit. Use type hinting and include a docstring.",
      "ideal": "from typing import Iterator\n\nclass FibonacciIterator:\n    \"\"\"An iterator that generates Fibonacci numbers up to a specified limit.\n\n    Args:\n        limit (int): The upper limit for generating Fibonacci numbers.\n\n    Example:\n        fib = FibonacciIterator(100)\n        for num in fib:\n            print(num)\n    \"\"\"\n\n    def __init__(self, limit: int) -> None:\n        self.limit = limit\n        self.previous = 0\n        self.current = 1\n\n    def __iter__(self) -> Iterator[int]:\n        return self\n\n    def __next__(self) -> int:\n        if self.previous > self.limit:\n            raise StopIteration\n\n        result = self.previous\n        self.previous, self.current = self.current, self.previous + self.current\n        return result"
    },
    {
      "input": "Create a function that performs matrix multiplication using nested list comprehensions. Use type hinting and include a docstring.",
      "ideal": "from typing import List\n\ndef matrix_multiply(matrix_a: List[List[float]], matrix_b: List[List[float]]) -> List[List[float]]:\n    \"\"\"Perform matrix multiplication using nested list comprehensions.\n\n    Args:\n        matrix_a (List[List[float]]): The first matrix.\n        matrix_b (List[List[float]]): The second matrix.\n\n    Returns:\n        List[List[float]]: The resulting matrix after multiplication.\n\n    Raises:\n        ValueError: If the matrices cannot be multiplied due to incompatible dimensions.\n\n    Example:\n        >>> a = [[1, 2], [3, 4]]\n        >>> b = [[5, 6], [7, 8]]\n        >>> matrix_multiply(a, b)\n        [[19, 22], [43, 50]]\n    \"\"\"\n    if len(matrix_a[0]) != len(matrix_b):\n        raise ValueError(\"Matrix dimensions are not compatible for multiplication.\")\n\n    return [\n        [sum(a * b for a, b in zip(row_a, col_b)) for col_b in zip(*matrix_b)]\n        for row_a in matrix_a\n    ]"
    },
    {
      "input": "Implement a simple cache decorator with a specified maximum size using a dictionary and deque. Use type hinting and include a docstring.",
      "ideal": "from collections import deque\nfrom functools import wraps\nfrom typing import Callable, Any, Dict, Deque\n\ndef simple_cache(max_size: int) -> Callable[[Callable[..., Any]], Callable[..., Any]]:\n    \"\"\"A decorator that implements a simple cache with a specified maximum size.\n\n    Args:\n        max_size (int): The maximum number of items to store in the cache.\n\n    Returns:\n        Callable[[Callable[..., Any]], Callable[..., Any]]: The decorated function.\n\n    Example:\n        @simple_cache(max_size=100)\n        def expensive_function(x, y):\n            # Some expensive computation\n            return x + y\n    \"\"\"\n    def decorator(func: Callable[..., Any]) -> Callable[..., Any]:\n        cache: Dict[Any, Any] = {}\n        call_order: Deque[Any] = deque()\n\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -> Any:\n            key = str(args) + str(kwargs)\n            if key not in cache:\n                if len(cache) >= max_size:\n                    oldest_key = call_order.popleft()\n                    del cache[oldest_key]\n                result = func(*args, **kwargs)\n                cache[key] = result\n                call_order.append(key)\n            else:\n                call_order.remove(key)\n                call_order.append(key)\n            return cache[key]\n\n        return wrapper\n\n    return decorator"
    },
    {
      "input": "Create a function that implements the bubble sort algorithm for a list of integers. Use type hinting and include a docstring with time complexity information.",
      "ideal": "from typing import List\n\ndef bubble_sort(arr: List[int]) -> List[int]:\n    \"\"\"Implement the bubble sort algorithm for a list of integers.\n\n    Args:\n        arr (List[int]): The list of integers to be sorted.\n\n    Returns:\n        List[int]: The sorted list of integers.\n\n    Time Complexity:\n        - Worst Case: O(n^2)\n        - Average Case: O(n^2)\n        - Best Case: O(n) when the list is already sorted\n\n    Space Complexity:\n        O(1) - In-place sorting algorithm\n\n    Example:\n        >>> bubble_sort([64, 34, 25, 12, 22, 11, 90])\n        [11, 12, 22, 25, 34, 64, 90]\n    \"\"\"\n    n = len(arr)\n    for i in range(n):\n        swapped = False\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n                swapped = True\n        if not swapped:\n            break\n    return arr"
    },
    {
      "input": "Implement a simple key-value store class with methods for setting, getting, and deleting keys, as well as listing all keys. Use type hinting and include a docstring.",
      "ideal": "from typing import Dict, Any, List, Optional\n\nclass SimpleKeyValueStore:\n    \"\"\"A simple key-value store implementation.\n\n    This class provides basic operations for a key-value store, including\n    setting, getting, and deleting keys, as well as listing all keys.\n\n    Example:\n        >>> store = SimpleKeyValueStore()\n        >>> store.set('name', 'John Doe')\n        >>> store.get('name')\n        'John Doe'\n        >>> store.list_keys()\n        ['name']\n        >>> store.delete('name')\n        >>> store.get('name')\n        None\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._store: Dict[str, Any] = {}\n\n    def set(self, key: str, value: Any) -> None:\n        \"\"\"Set a value for a given key.\n\n        Args:\n            key (str): The key to set.\n            value (Any): The value to associate with the key.\n        \"\"\"\n        self._store[key] = value\n\n    def get(self, key: str) -> Optional[Any]:\n        \"\"\"Get the value associated with a given key.\n\n        Args:\n            key (str): The key to retrieve.\n\n        Returns:\n            Optional[Any]: The value associated with the key, or None if the key doesn't exist.\n        \"\"\"\n        return self._store.get(key)\n\n    def delete(self, key: str) -> None:\n        \"\"\"Delete a key-value pair from the store.\n\n        Args:\n            key (str): The key to delete.\n        \"\"\"\n        self._store.pop(key, None)\n\n    def list_keys(self) -> List[str]:\n        \"\"\"List all keys in the store.\n\n        Returns:\n            List[str]: A list of all keys in the store.\n        \"\"\"\n        return list(self._store.keys())"
    }
  ]